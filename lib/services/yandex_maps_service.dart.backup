import 'dart:math';
import 'package:yandex_mapkit/yandex_mapkit.dart';
import '../models/route_info.dart';

/// –°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Yandex MapKit SDK
class YandexMapsService {
  static final YandexMapsService instance = YandexMapsService._();
  YandexMapsService._();

  bool _isInitialized = false;

  /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MapKit (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
  Future<void> initialize() async {
    if (_isInitialized) return;

    try {
      print('üó∫Ô∏è [YANDEX MAPKIT] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...');
      // MapKit –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–ª—é—á –∏–∑ AndroidManifest.xml –∏ Info.plist
      _isInitialized = true;
      print('‚úÖ [YANDEX MAPKIT] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ');
    } catch (e) {
      print('‚ùå [YANDEX MAPKIT] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: $e');
    }
  }

  /// –ì–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ: –∞–¥—Ä–µ—Å ‚Üí –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
  Future<Coordinates?> geocode(String address) async {
    if (!_isInitialized) await initialize();

    print('üó∫Ô∏è [YANDEX MAPKIT] –ì–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–¥—Ä–µ—Å–∞: "$address"');

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º YandexSearch.searchByText –¥–ª—è –ø–æ–∏—Å–∫–∞ –∞–¥—Ä–µ—Å–∞
      // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Record: (SearchSession, Future<SearchSessionResult>)
      final resultWithSession = YandexSearch.searchByText(
        searchText: address,
        geometry: Geometry.fromBoundingBox(
          const BoundingBox(
            northEast: Point(latitude: 90.0, longitude: 180.0),
            southWest: Point(latitude: -90.0, longitude: -180.0),
          ),
        ),
        searchOptions: const SearchOptions(
          searchType: SearchType.geo,
          geometry: false,
        ),
      );

      // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–∑ Record
      final session = resultWithSession.$1;  // SearchSession
      final result = await resultWithSession.$2;  // Future<SearchSessionResult>

      // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é
      await session.close();

      if (result.error != null) {
        print('‚ö†Ô∏è [YANDEX MAPKIT] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ${result.error}');
        return _getMockCoordinates(address);
      }

      if (result.items != null && result.items!.isNotEmpty) {
        final firstItem = result.items!.first;
        
        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ geometry
        if (firstItem.geometry.isNotEmpty) {
          final point = firstItem.geometry.first.point;
          
          if (point != null) {
            final coords = Coordinates(
              latitude: point.latitude,
              longitude: point.longitude,
            );
            print('‚úÖ [YANDEX MAPKIT] –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞–π–¥–µ–Ω—ã: $coords');
            return coords;
          }
        }
      }

      print('‚ö†Ô∏è [YANDEX MAPKIT] –ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω');
      return _getMockCoordinates(address);
    } catch (e) {
      print('‚ùå [YANDEX MAPKIT] –û—à–∏–±–∫–∞ –≥–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è: $e');
      return _getMockCoordinates(address);
    }
  }

  /// –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç –∏ –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
  Future<RouteInfo?> calculateRoute(
    String fromAddress,
    String toAddress,
  ) async {
    if (!_isInitialized) await initialize();

    print('üöó [YANDEX MAPKIT] ========== –†–ê–°–ß–Å–¢ –ú–ê–†–®–†–£–¢–ê ==========');
    print('üöó [YANDEX MAPKIT] –û—Ç: $fromAddress');
    print('üöó [YANDEX MAPKIT] –î–æ: $toAddress');

    try {
      // –®–∞–≥ 1: –ì–µ–æ–∫–æ–¥–∏—Ä—É–µ–º –æ–±–∞ –∞–¥—Ä–µ—Å–∞
      final fromCoords = await geocode(fromAddress);
      final toCoords = await geocode(toAddress);

      if (fromCoords == null || toCoords == null) {
        print('‚ùå [YANDEX MAPKIT] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã');
        return null;
      }

      print('üìç [YANDEX MAPKIT] –û—Ç: $fromCoords');
      print('üìç [YANDEX MAPKIT] –î–æ: $toCoords');

      // –®–∞–≥ 2: –°—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç —á–µ—Ä–µ–∑ DrivingRouter
      final drivingRouter = DirectionsFactory.createDrivingRouter(
        DrivingRouterType.combined,
      );

      final requestPoints = [
        RequestPoint(
          point: Point(
            latitude: fromCoords.latitude,
            longitude: fromCoords.longitude,
          ),
          requestPointType: RequestPointType.wayPoint,
        ),
        RequestPoint(
          point: Point(
            latitude: toCoords.latitude,
            longitude: toCoords.longitude,
          ),
          requestPointType: RequestPointType.wayPoint,
        ),
      ];

      final resultWithSession = drivingRouter.requestRoutes(
        points: requestPoints,
        drivingOptions: const DrivingOptions(
          initialAzimuth: null,
          routesCount: 1,
          avoidTolls: false,
          avoidUnpaved: false,
          avoidPoorConditions: false,
        ),
      );

      // –ñ–¥–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      final result = await resultWithSession.result;

      if (result.routes != null && result.routes!.isNotEmpty) {
        final route = result.routes!.first;

        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∏ –≤—Ä–µ–º—è
        final metadata = route.metadata as DrivingRouteMetadata;
        final distanceMeters = metadata.weight.distance.value;
        final durationSeconds = metadata.weight.time.value;

        final distanceKm = distanceMeters / 1000.0;
        final durationMinutes = durationSeconds / 60.0;

        final routeInfo = RouteInfo(
          distance: distanceKm,
          duration: durationMinutes,
          fromAddress: fromAddress,
          toAddress: toAddress,
        );

        print('‚úÖ [YANDEX MAPKIT] –ú–∞—Ä—à—Ä—É—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω:');
        print('   üìè –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${distanceKm.toStringAsFixed(1)} –∫–º');
        print('   ‚è±Ô∏è –í—Ä–µ–º—è: ${durationMinutes.toInt()} –º–∏–Ω—É—Ç');
        print('üöó [YANDEX MAPKIT] =========================================');

        return routeInfo;
      }

      print(
        '‚ö†Ô∏è [YANDEX MAPKIT] –ú–∞—Ä—à—Ä—É—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—á–µ—Ç –ø–æ –ø—Ä—è–º–æ–π',
      );

      // Fallback: —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ì–∞–≤–µ—Ä—Å–∏–Ω–∞
      return _calculateRouteByDistance(
        fromCoords,
        toCoords,
        fromAddress,
        toAddress,
      );
    } catch (e) {
      print('‚ùå [YANDEX MAPKIT] –û—à–∏–±–∫–∞ —Ä–∞—Å—á—ë—Ç–∞ –º–∞—Ä—à—Ä—É—Ç–∞: $e');
      print('‚ö†Ô∏è [YANDEX MAPKIT] –ü—Ä–æ–±—É–µ–º —Ä–∞—Å—á–µ—Ç –ø–æ –ø—Ä—è–º–æ–π...');

      // Fallback: —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
      final fromCoords = await geocode(fromAddress);
      final toCoords = await geocode(toAddress);

      if (fromCoords != null && toCoords != null) {
        return _calculateRouteByDistance(
          fromCoords,
          toCoords,
          fromAddress,
          toAddress,
        );
      }

      return null;
    }
  }

  /// –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ –∞–¥—Ä–µ—Å–æ–≤ (–∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ)
  Future<List<String>> getSuggestions(String query) async {
    if (query.length < 3) {
      return []; // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫–∏ –¥–ª—è —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    }

    if (!_isInitialized) await initialize();

    print('üí° [YANDEX MAPKIT] –ü–æ–∏—Å–∫ –ø–æ–¥—Å–∫–∞–∑–æ–∫ –¥–ª—è: "$query"');

    try {
      final resultWithSession = YandexSearch.searchByText(
        searchText: query,
        geometry: Geometry.fromBoundingBox(
          const BoundingBox(
            northEast: Point(latitude: 90.0, longitude: 180.0),
            southWest: Point(latitude: -90.0, longitude: -180.0),
          ),
        ),
        searchOptions: const SearchOptions(
          searchType: SearchType.geo,
          geometry: false,
          snippets: [SearchSnippet.business],
        ),
      );

      final result = await resultWithSession.result;

      if (result.items != null && result.items!.isNotEmpty) {
        final suggestions = result.items!
            .take(10) // –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 10 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            .map((item) {
              // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å
              if (item.toponymMetadata != null) {
                return item.toponymMetadata!.address.formattedAddress;
              } else if (item.businessMetadata != null) {
                return item.businessMetadata!.address.formattedAddress;
              }
              return item.name;
            })
            .where((s) => s.isNotEmpty)
            .toList();

        print('‚úÖ [YANDEX MAPKIT] –ù–∞–π–¥–µ–Ω–æ –ø–æ–¥—Å–∫–∞–∑–æ–∫: ${suggestions.length}');
        return suggestions;
      }

      return [];
    } catch (e) {
      print('‚ùå [YANDEX MAPKIT] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–æ–∫: $e');
      return [];
    }
  }

  // ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ==========

  /// –ú–æ–∫–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤ (fallback)
  Coordinates? _getMockCoordinates(String address) {
    final lowerAddress = address.toLowerCase();

    if (lowerAddress.contains('–ø–µ—Ä–º—å') || lowerAddress.contains('perm')) {
      return Coordinates(latitude: 58.0, longitude: 56.3);
    } else if (lowerAddress.contains('–µ–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥') ||
        lowerAddress.contains('yekaterinburg')) {
      return Coordinates(latitude: 56.8, longitude: 60.6);
    } else if (lowerAddress.contains('–º–æ—Å–∫–≤–∞') ||
        lowerAddress.contains('moscow')) {
      return Coordinates(latitude: 55.75, longitude: 37.62);
    } else if (lowerAddress.contains('—Å–∞–Ω–∫—Ç-–ø–µ—Ç–µ—Ä–±—É—Ä–≥') ||
        lowerAddress.contains('petersburg')) {
      return Coordinates(latitude: 59.93, longitude: 30.36);
    } else if (lowerAddress.contains('–¥–æ–Ω–µ—Ü–∫') ||
        lowerAddress.contains('donetsk')) {
      return Coordinates(latitude: 48.0, longitude: 37.8);
    } else if (lowerAddress.contains('—Ä–æ—Å—Ç–æ–≤') ||
        lowerAddress.contains('rostov')) {
      return Coordinates(latitude: 47.2, longitude: 39.7);
    } else if (lowerAddress.contains('–∫–∞–∑–∞–Ω—å') ||
        lowerAddress.contains('kazan')) {
      return Coordinates(latitude: 55.8, longitude: 49.1);
    } else if (lowerAddress.contains('—á–µ–ª—è–±–∏–Ω—Å–∫') ||
        lowerAddress.contains('chelyabinsk')) {
      return Coordinates(latitude: 55.2, longitude: 61.4);
    } else if (lowerAddress.contains('—É—Ñ–∞') || lowerAddress.contains('ufa')) {
      return Coordinates(latitude: 54.7, longitude: 55.9);
    }

    print('‚ö†Ô∏è [YANDEX MAPKIT] –ê–¥—Ä–µ—Å –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω: $address');
    return null;
  }

  /// –†–∞—Å—á–µ—Ç –º–∞—Ä—à—Ä—É—Ç–∞ –ø–æ –ø—Ä—è–º–æ–π (fallback)
  RouteInfo _calculateRouteByDistance(
    Coordinates from,
    Coordinates to,
    String fromAddress,
    String toAddress,
  ) {
    final distance = _calculateDistance(from, to);
    final duration = distance / 80 * 60; // –ü—Ä–∏–º–µ—Ä–Ω–æ 80 –∫–º/—á

    print('‚úÖ [YANDEX MAPKIT] –ú–∞—Ä—à—Ä—É—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –ø–æ –ø—Ä—è–º–æ–π:');
    print('   üìè –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${distance.toStringAsFixed(1)} –∫–º');
    print('   ‚è±Ô∏è –í—Ä–µ–º—è: ${duration.toInt()} –º–∏–Ω—É—Ç');

    return RouteInfo(
      distance: distance,
      duration: duration,
      fromAddress: fromAddress,
      toAddress: toAddress,
    );
  }

  /// –†–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ì–∞–≤–µ—Ä—Å–∏–Ω–∞
  /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –∫–∏–ª–æ–º–µ—Ç—Ä–∞—Ö
  double _calculateDistance(Coordinates from, Coordinates to) {
    const earthRadiusKm = 6371.0;

    final lat1Rad = from.latitude * pi / 180;
    final lat2Rad = to.latitude * pi / 180;
    final dLatRad = (to.latitude - from.latitude) * pi / 180;
    final dLonRad = (to.longitude - from.longitude) * pi / 180;

    final a =
        sin(dLatRad / 2) * sin(dLatRad / 2) +
        cos(lat1Rad) * cos(lat2Rad) * sin(dLonRad / 2) * sin(dLonRad / 2);

    final c = 2 * atan2(sqrt(a), sqrt(1 - a));

    return earthRadiusKm * c;
  }
}
